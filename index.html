<!DOCTYPE html> 
<html> 
   <head> 
      <title>Canvas Image Gallery</title>  
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta name="mobile-web-app-capable" content="yes">
      <link rel="stylesheet" href="w3.css">
      <link rel="stylesheet" href="w3-colors-flat.css">
   <style>
      /* site header/footer sizing variables */
      :root{
         --header-height:64px; /* adjust if your header is taller */
         --footer-height:48px; /* adjust if your footer is taller */
         --page-max-width:980px; /* max width of the centered content area */
         --gutter:16px; /* page side gutter for small screens */

         /* space reserved for controls and paragraph when sizing canvas */
         --controls-space:120px;
      }

      /* keep page at full width but center main content; remove body padding so header/footer can't be accidentally overridden by external CSS */
      body {
         margin: 0;
         font-family: sans-serif;
         background: #fff;
      }

      /* header/footer fixed to viewport edges and full width */
      .site-header,
      .site-footer{
         position: fixed;
         left: 0;
         right: 0;            /* ensures full width even if width:100% overridden */
         width: 100%;
         display: flex;
         align-items: center;
         justify-content: center;
         z-index: 1000; /* keep above page content */
         padding: 0 16px;
         box-sizing: border-box;
      }
      .site-header{ top: 0; height: var(--header-height); }
      .site-footer{ bottom: 0; height: var(--footer-height); }

      /* main content wrapper reserves space so header/footer do not overlap */
      .main {
         box-sizing: border-box;
         padding-top: var(--header-height);    /* push content below header */
         padding-bottom: var(--footer-height); /* avoid footer overlap */
         width: 100%;
         max-width: var(--page-max-width);
         margin: 0 auto;                       /* center on wide screens */
         padding-left: var(--gutter);
         padding-right: var(--gutter);

         /* ensure main can scroll internally if content is taller than available space,
            but keep header/footer visible and avoid page-level scrolling that hides buttons */
         max-height: calc(100vh - var(--header-height) - var(--footer-height));
         overflow: auto;
      }

      /* gallery wrapper ensures paragraph left-edge aligns with canvas left-edge */
      .gallery {
         display: flex;
         flex-direction: column;
         align-items: center;        /* center the gallery block on the page */
         width: 100%;
         max-width: var(--page-max-width); /* center the whole gallery block */
         margin: 0 auto;                    /* center gallery on the page */
         gap: 8px;
      }
      .gallery p {
         margin: 0;            /* remove default margins */
         line-height: 1.4;
         width: 100%;          /* will match media-wrap width when JS sets it */
      }

      /* wrapper that will be resized by JS to match the computed canvas width
         so paragraph, canvas and controls remain the same width and centered */
      .media-wrap {
         margin: 0 auto;       /* center this block horizontally */
         width: auto;          /* JS will set an explicit width in px */
      }

      /* responsive canvas: CSS width follows the media-wrap width, real pixel size set by JS */
      #galleryCanvas {
         display: block;
         width: 100%;               /* fills the media-wrap */
         height: auto;              /* JS controls internal pixel buffer height */
         aspect-ratio: 3 / 2;
         max-width: 100%;
         border: 2px solid #333;
         margin: 0;                 /* left edge lines up with paragraph in media-wrap */
         background: #fff;
      }

      /* center the buttons horizontally inside the media-wrap */
      .controls {
         width: 100%;
         display: flex;
         justify-content: center; /* buttons centered relative to media-wrap width */
         gap: 10px;
         margin-bottom: 12px;
      }
      .controls button { margin: 0; padding: 10px 20px; font-size: 16px; }

      @media (max-width:480px){
         :root{ --gutter:8px; --controls-space:110px; }
         .controls button{ padding:8px 12px; font-size:14px; }
      }
   </style>
   </head> 
   
   <body> 

      <header class="w3-container w3-flat-carrot site-header">
           <h1>Example Gallery</h1>
      </header>

      <!-- main wrapper: preserves space for fixed header/footer so they do not overlap content -->
      <div class="w3-container main"><!-- place main content here and it will show up between header and footer.-->
         <div class="gallery">
            <p>Below is an example gallery with six images.</p>

            <!-- media-wrap groups the paragraph, canvas and buttons so they stay the same width -->
            <div class="media-wrap">
               <!-- Canvas element where images will be drawn -->
               <canvas id="galleryCanvas" width="600" height="400"></canvas>

               <!-- Gallery controls: left/right buttons centered under the canvas -->
               <div class="controls"> <!-- wrapper to center the buttons -->
                  <button id="prevBtn" class="w3-button w3-light-grey" aria-label="Previous image">◀ Prev</button>
                  <button id="nextBtn" class="w3-button w3-light-grey" aria-label="Next image">Next ▶</button>
               </div>
            </div>
         </div>
      </div><!-- /content -->
      
      <footer class="w3-container w3-flat-carrot site-footer">
         <p>This is the footer!</p>
      </footer>

   <!-- Gallery script: preloads images and handles drawing + button clicks -->
   <script>
   // get a reference to the canvas element by its id
   const canvas = document.getElementById('galleryCanvas'); // canvas DOM element
   const ctx = canvas.getContext('2d'); // 2D drawing context used to draw images

   // list of image URLs (replace these paths with your real image files)
   const imagePaths = [
     'images/img1.jpg', // image 0
     'images/img2.jpg', // image 1
     'images/img3.jpg', // image 2
     'images/img4.jpg', // image 3
     'images/img5.jpg', // image 4
     'images/img6.jpg'  // image 5
   ];

   // array to hold preloaded Image objects
   const images = new Array(imagePaths.length); // same length as imagePaths
   let loadedCount = 0; // how many images have finished loading
   let currentIndex = 0; // index of the image currently shown

   // helper: draw an image scaled to fit the canvas while preserving aspect ratio and centering it
   function drawImageScaled(img) {
     // handle missing image
     if (!img) {
       // clear the visible area (use CSS pixels so clearing matches drawing coordinates)
       const dpr = window.devicePixelRatio || 1;
       const cssW = canvas.width / dpr;
       const cssH = canvas.height / dpr;
       ctx.clearRect(0, 0, cssW, cssH);
       return;
     }

     // device pixel ratio (1 on normal screens, >1 on HiDPI)
     const dpr = window.devicePixelRatio || 1;

     // compute canvas size in CSS pixels (drawing coordinates after ctx.setTransform use CSS pixels)
     const cssWidth = canvas.width / dpr;
     const cssHeight = canvas.height / dpr;

     // clear the canvas in CSS-pixel coordinates
     ctx.clearRect(0, 0, cssWidth, cssHeight);

     // calculate scale to fit image into the CSS-sized canvas while preserving aspect ratio
     const scale = Math.min(cssWidth / img.width, cssHeight / img.height);

     // compute the displayed width and height (in CSS pixels)
     const w = img.width * scale;
     const h = img.height * scale;

     // compute top-left coordinates to center the image on the canvas (CSS pixels)
     const x = (cssWidth - w) / 2;
     const y = (cssHeight - h) / 2;

     // draw the image using CSS-pixel coordinates; the previously set transform will map them to device pixels
     ctx.drawImage(img, x, y, w, h);
   }

   // preload each image in imagePaths array
   imagePaths.forEach((src, i) => {
     const img = new Image(); // create a new Image object
     img.onload = () => {     // when the image finishes loading...
       images[i] = img;       // store the loaded Image object
       loadedCount += 1;      // increment the loaded counter

       // once the first image is loaded (or all are loaded) draw the initial image
       // this ensures something appears quickly rather than waiting for all images
       if (i === currentIndex) drawImageScaled(images[currentIndex]);
       // optionally, you could wait for all to load: if (loadedCount === images.length) { ... }
     };
     img.onerror = () => {    // handle a load error for debugging
       console.error('Failed to load image:', src); // log which image failed
       images[i] = null;      // set slot to null if loading fails
       loadedCount += 1;      // still count it so any "all loaded" logic moves on
     };
     img.src = src; // begin loading the image by setting src
   });

   // button references
   const prevBtn = document.getElementById('prevBtn'); // left button element
   const nextBtn = document.getElementById('nextBtn'); // right button element

   // function to show the image at currentIndex (with wrapping)
   function showCurrentImage() {
     // normalize index to be within bounds and wrap around
     if (currentIndex < 0) currentIndex = images.length - 1;
     if (currentIndex >= images.length) currentIndex = 0;

     // draw the image (may be null if it failed to load)
     drawImageScaled(images[currentIndex]);
   }

   // click handler for previous button: go to previous image then draw
   prevBtn.addEventListener('click', () => {
     currentIndex -= 1; // move one step left
     showCurrentImage(); // update the canvas
   });

   // click handler for next button: go to next image then draw
   nextBtn.addEventListener('click', () => {
     currentIndex += 1; // move one step right
     showCurrentImage(); // update the canvas
   });

   // keyboard support: left/right arrow keys cycle images
   window.addEventListener('keydown', (ev) => {
     if (ev.key === 'ArrowLeft') { // left arrow pressed
       currentIndex -= 1;
       showCurrentImage();
     } else if (ev.key === 'ArrowRight') { // right arrow pressed
       currentIndex += 1;
       showCurrentImage();
     }
   });

   // Responsive resize: set canvas internal pixel size to match CSS size * devicePixelRatio,
   // preserve the canvas aspect ratio, and redraw the current image.
   function resizeCanvasToDisplaySize() {
     const dpr = window.devicePixelRatio || 1;

     // compute header/footer sizes from CSS vars
     const rootStyle = getComputedStyle(document.documentElement);
     const headerH = parseInt(rootStyle.getPropertyValue('--header-height')) || 64;
     const footerH = parseInt(rootStyle.getPropertyValue('--footer-height')) || 48;

     // measure paragraph and controls so we can reserve their height
     const gallery = document.querySelector('.gallery');
     const mediaWrap = document.querySelector('.media-wrap');
     const para = gallery.querySelector('p');
     const controls = mediaWrap.querySelector('.controls');

     const paraH = para ? para.getBoundingClientRect().height : 0;
     const controlsH = controls ? controls.getBoundingClientRect().height : 0;
     const paddingReserve = 24; // small breathing space

     // compute available vertical space for the canvas so it never forces scrolling
     const availableHeight = Math.max(50, Math.floor(window.innerHeight - headerH - footerH - paraH - controlsH - paddingReserve));

     // use gallery width as the max available width for the canvas
     const galleryStyle = getComputedStyle(gallery);
     const galleryPaddingLeft = parseFloat(galleryStyle.paddingLeft) || 0;
     const galleryPaddingRight = parseFloat(galleryStyle.paddingRight) || 0;
     const availableWidth = Math.max(1, Math.floor(gallery.clientWidth - galleryPaddingLeft - galleryPaddingRight));

     // desired CSS width (start from available width); compute height via aspect ratio
     const aspect = 3 / 2; // width / height
     let cssWidth = availableWidth;
     let cssHeight = Math.round(cssWidth / aspect);

     // if cssHeight is too tall for availableHeight, reduce cssWidth so height fits
     if (cssHeight > availableHeight) {
       cssHeight = availableHeight;
       cssWidth = Math.round(cssHeight * aspect);
     }

     // apply computed width to the media-wrap so paragraph, canvas and controls line up and are centered
     if (mediaWrap) {
       mediaWrap.style.width = cssWidth + 'px';
     }

     // set internal pixel size taking devicePixelRatio into account
     const displayWidth  = cssWidth * dpr;
     const displayHeight = cssHeight * dpr;

     if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
       canvas.width  = displayWidth;
       canvas.height = displayHeight;
       // set CSS layout size to our calculated CSS pixels
       canvas.style.width  = cssWidth + 'px';
       canvas.style.height = cssHeight + 'px';
       // scale drawing so 1 unit = 1 CSS pixel
       ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
     }
   }

   // call resize once and on every window resize / orientation change
   function handleResizeAndRedraw() {
     resizeCanvasToDisplaySize();
     drawImageScaled(images[currentIndex]); // redraw at new size
   }

   window.addEventListener('resize', handleResizeAndRedraw);
   window.addEventListener('orientationchange', handleResizeAndRedraw);

   // ensure canvas sized correctly on initial load
   window.addEventListener('load', () => {
     handleResizeAndRedraw();
   });

   // If images are loaded after initial load, ensure redraw when each image arrives (already present in your loader)
   imagePaths.forEach((src, i) => {
     const img = images[i];
     if (img) img.onload = () => { drawImageScaled(img); };
   });
   </script>

</body>
</html>
